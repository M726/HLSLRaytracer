// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
//The Notes Section
//Albedo - Base Color
//Specular - Metalness
//Diffuse - Non-metalic/roughness
    //Probablility for diffuse ray to have some angle in radians p(x)=(acos(2x-1)-pi/2)
        //modeled from lambert's cosine law

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float _RandomSeed;

static const float PI = 3.14159265f;
static const float3 f3one = float3(1.0, 1.0, 1.0);
static const float3 f3zero = float3(0.0, 0.0, 0.0);

//Camera Setup
float2 _ClippingPlanes;


float3x3 GetRotationMatrix(float3 angles)
{
    float yaw = angles.z;
    float pitch = angles.y;
    float roll = angles.x;
    
    float sa = sin(yaw);
    float sb = sin(pitch);
    float sc = sin(roll);
    
    float ca = cos(yaw);
    float cb = cos(pitch);
    float cc = cos(roll);
    
    return float3x3(
        ca * cb, ca * sb * sc - sa * cc, ca * sb * cc + sa * sc,
        sa * cb, sa * sb * sc + ca * cc, sa * sb * cc - ca * sc,
        -sb, cb * sc, cb * cc);

}

float3x3 GetRotationMatrix(float4 quaternion)
{
    float4 q = float4(-quaternion.x, quaternion.y, quaternion.z, quaternion.w) / length(quaternion);
    
    float m11 = 1 - 2 * (q.y * q.y + q.z * q.z);
    float m12 = 2 * (q.x * q.y - q.z * q.w);
    float m13 = 2 * (q.x * q.z + q.y * q.w);
    
    float m21 = 2 * (q.x * q.y + q.z * q.w);
    float m22 = 1 - 2 * (q.x * q.x + q.z * q.z);
    float m23 = 2 * (q.y * q.z - q.x * q.w);
    
    float m31 = 2 * (q.x * q.z - q.y * q.w);
    float m32 = 2 * (q.y * q.z - q.x * q.w);
    float m33 = 1 - 2 * (q.x * q.x + q.y * q.y);
    
    return float3x3(m11, m12, m13, m21, m22, m23, m31, m32, m33);
    //return float3x3(m11, m13, m12, m21, m23, m22, m31, m33, m32);
}
float3x3 GetInverseMatrix(float3x3 r)
{
    //I'm almost certain this works based on AA^-1=I tests
    //From linear algebra book 181
        //A^-1 = 1/(det(A)) * adj(A)
        //adj(A) = transpose of the matrix of cofactors
    float m11 = r._22 * r._33 - r._23 * r._32;
    float m12 = -r._12 * r._33 + r._13 * r._32;
    float m13 = r._12 * r._23 - r._13 * r._22;
    
    float m21 = -r._21 * r._33 + r._23 * r._31;
    float m22 = r._11 * r._33 - r._13 * r._31;
    float m23 = -r._11 * r._23 + r._13 * r._21;
    
    float m31 = r._21 * r._33 - r._22 * r._31;
    float m32 = -r._11 * r._32 + r._12 * r._31;
    float m33 = r._11 * r._22 - r._12 * r._21;
    
    return (1 / determinant(r)) * float3x3(m11, m12, m13, m21, m22, m23, m31, m32, m33);

}

struct MaterialProperties
{
    float3 diffuseColor;
    float3 specularColor;
    float3 emissiveColor;
    float diffuse;
    float specular;
    float emissive;
    float refraction;
    float extinction;
};

struct ShaderObject
{
    int type;
    float3 position;
    float3 scale;
    float3 rotation;
    MaterialProperties material;
};
struct Ray
{
    float3 origin;
    float3 direction;
};
struct RayHit
{
    float3 position;
    float3 normal;
    float distance;
    MaterialProperties mat;
};
struct LightDirectional
{
    float3 position;
    float3 direction;
    float3 color;
    float intensity;
};

struct LightPoint
{
    float3 position;
    float3 color;
    float intensity;
};


StructuredBuffer<ShaderObject> _Objects;
StructuredBuffer<double> _PixelOffset;

MaterialProperties CreateMaterial()
{
    MaterialProperties mat;
    mat.diffuseColor = f3one;
    mat.diffuse = 1;
    mat.emissive = 0;
    mat.emissiveColor = float3(1, 1, 1);
    mat.specular = 1;
    mat.specularColor = float3(1, 1, 1);
    mat.refraction = 1;
    mat.extinction = 3;
    return mat;
}

RayHit CreateRayHit()
{
    RayHit ret;
    ret.distance = 1.#INF; //any hit should be less than this.
    ret.position = float3(0.0, 0.0, 0.0);
    ret.normal = float3(0.0, 0.0, 0.0);
    ret.mat = CreateMaterial();
    return ret;

}

float rand(float2 co)
{
    return (frac(sin(dot(float2(co.xy), float2(12.9898, 78.233))) * 43758.5453)) * 1;
}
float3 rand3(float3 co)
{
    return float3(rand(co.xy * co.yy), rand(co.yz), rand(co.xz));
}
bool randBool(float co, float cutoff)
{
    if (rand(float2(co, co + 1)) < cutoff)
        return true;
    return false;
}

void IntersectionTestPlane(ShaderObject object, Ray ray, inout RayHit bestHit)
{
    //float3 normal = float3(0, 1, 0);
    float3x3 rotationMatrix = GetRotationMatrix(object.rotation);
    float3 normal = mul(rotationMatrix, float3(0, 1, 0)); //TODO: precompute this - it should take far fewer calculations
    
    float normalDotDirection = dot(normal, ray.direction);
    if (normalDotDirection < 0)
    { 
        float t = dot((object.position - ray.origin), normal) / normalDotDirection;
        float3 hitPoint = ray.origin + ray.direction * t;
        if (t > 0 && t < bestHit.distance)
        {
            //float3 localposition = mul(mul(GetInverseMatrix(GetRotationMatrix(object.rotation)), GetRotationMatrix(object.rotation)), float3(0.7, 1, 0));
            float3 localposition = mul(transpose(rotationMatrix), float3(hitPoint));
            if (localposition.z > -10* object.scale.z / 2 && localposition.z < 10* object.scale.z / 2
                && localposition.x > -10 * object.scale.x / 2 && localposition.x < 10 * object.scale.x / 2)
            {
                bestHit.position = hitPoint;
                bestHit.normal = normalize(normal);
                bestHit.distance = t;
                bestHit.mat = object.material;
                bestHit.mat.diffuseColor = normal;
            }
        }
    }
}

void IntersectionTestSphere(ShaderObject object, Ray ray, inout RayHit bestHit)
{
    float3 dPosition = ray.origin - object.position;
    float uDotDPosition = -dot(ray.direction, dPosition);
    float del = pow(uDotDPosition, 2) - (dot(dPosition, dPosition) - pow(length(object.scale), 2));

    if (del < 0)
        return; //No Intersection
    
    float sqrtDel = sqrt(del);
    float distanceFromLineOrigin = uDotDPosition - sqrtDel > 0 ? uDotDPosition - sqrtDel : uDotDPosition + sqrtDel;
    float3 position = ray.origin + distanceFromLineOrigin * ray.direction;
    
    if (!(dot((position - object.position), ray.direction) > 0)  && distanceFromLineOrigin - _ClippingPlanes.x > 0 && distanceFromLineOrigin - _ClippingPlanes.y < 0 && distanceFromLineOrigin < bestHit.distance)
    {
        bestHit.position = position;
        bestHit.normal = normalize(position - object.position);
        bestHit.distance = distanceFromLineOrigin;
        bestHit.mat = object.material;
    }
}
RayHit Trace(Ray ray)
{
    //Empty Ray Collision
    ray.direction = normalize(ray.direction);
    RayHit bestHit = CreateRayHit();
    
    uint numObjects, stride;
    _Objects.GetDimensions(numObjects, stride);
    for (uint i = 0; i < numObjects; i++)
    {
        switch (_Objects[i].type)
        {
            case 0:
                IntersectionTestSphere(_Objects[i], ray, bestHit);
                break;
            case 1:
                IntersectionTestPlane(_Objects[i], ray, bestHit);
                break;
        }

    }
    
    return bestHit;
}
float3 ShadowRay(RayHit hit)
{
    float3 color = float3(1, 1, 1);
    float3 position = float3(-1, 6, 11);
        float distance = length(position - hit.position);
        Ray ray;
        ray.direction = normalize(position - hit.position);
        ray.origin = hit.position - hit.normal * 0.001;
        if (Trace(ray).distance > distance) //collision before light
        {
            //intensity += dot(hit.normal, ray.direction) * _LightPoint[light].color * _LightPoint[light].intensity / (distance * distance * 4.0 * PI);
            return color * 800 / (distance * distance * 4.0 * PI);
        }
    return f3zero;
}

float3 Shade(RayHit hit, float3 colorMultiplier)
{
    //return ShadowRay(hit);
    //return colorMultiplier; //(ShadowRay(hit) + hit.mat.emissivity ) * (hit.mat.diffuseColor);
    return colorMultiplier;// * (ShadowRay(hit));
}
float3 RayTrace(Ray ray)
{
    
    RayHit hit = CreateRayHit();
    //Cast Ray
    hit = Trace(ray);
    
    float3 colorMultiplier = f3zero;
    float3 result = Shade(hit, colorMultiplier);
    colorMultiplier = hit.mat.diffuseColor;
    
    for (uint i = 0; i < 1; i++)
    {
        if (hit.distance < 1.#INF)
        {
            float n1 = 1.0;
            float n2 = hit.mat.refraction;
            float theta1 = acos(dot(normalize(hit.normal), normalize(-ray.direction)));
            float theta2 = asin((n1 / n2 * sin(theta1)));
            float rs = pow(abs((n1 * cos(theta1) - n2 * cos(theta2)) / (n1 * cos(theta1) + n2 * cos(theta2))), 2);
            float rp = pow(abs((n1 * cos(theta2) - n2 * cos(theta1)) / (n1 * cos(theta2) + n2 * cos(theta1))), 2);
            float reflectance = (rs + rp) / 2.0;
            
            
            ray.origin = hit.position;
            
            if (randBool(ray.direction.x * ray.direction.y * ray.direction.z, reflectance))
            {
                //Specular reflection 
                    //TODO: Add specular roughness
                float3 mirrorScatteringDirection = reflect(ray.direction, hit.normal);
                ray.direction = mirrorScatteringDirection;
                hit = Trace(ray);
                hit.mat.diffuseColor = f3one;
                result += Shade(hit, colorMultiplier) * hit.mat.specular;
            }else{
                //Diffuse Reflection
                float3 lambertianScatteringDirection = rand3(ray.direction);
                lambertianScatteringDirection = normalize(lambertianScatteringDirection / length(lambertianScatteringDirection) + hit.normal);
                ray.direction = lambertianScatteringDirection;
                hit = Trace(ray);
                result += Shade(hit, colorMultiplier) * hit.mat.diffuse;
                colorMultiplier *= hit.mat.diffuseColor;
            }
            
            
        }
        else
        {
            //result *= float3(0.78, 0.88, 1.0) * (0.2 * (dot(ray.direction, normalize(float3(1, 5, 1))) - 1) + 1);
            break;
        }
    }
    return result;
}


Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = normalize(direction);
    return ray;
}
Ray CreateCameraRay(double2 uv)
{
    // Transform the camera origin to world space
    double3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    double3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = (direction / length(direction));
    
    return CreateRay(origin, direction);
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    
    double2 po = double2(_PixelOffset[0], _PixelOffset[1]);
    double2 uv = double2((id.xy + po) / double2(width, height) * 2.0 - 1.0);
    
    Ray ray = CreateCameraRay(uv);
    
    float3 result = RayTrace(ray);
    
    Result[id.xy] = float4(result, 1.0);
    //Result[id.xy] = float4(0.5, 0.5, 0.5, 1.0); //Test output color
    
    //Result[id.xy] = float4(id.x & id.y, (id.x & 15) / 15.0, (id.y & 15) / 15.0, 0.0);
}
