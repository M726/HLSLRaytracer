#pragma kernel CSMain


RWTexture2D<float4> Result;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float _RandomSeed;
int _Rays;

static const float PI = 3.14159265f;
static const float epsilon = 0.00001f;

static const float3 f3one = float3(1.0, 1.0, 1.0);
static const float3 f3zero = float3(0.0, 0.0, 0.0);
static const float3 f3X = float3(1, 0, 0);
static const float3 f3Y = float3(0, 1, 0);
static const float3 f3Z = float3(0, 0, 1);

//Camera Setup
float2 _ClippingPlanes;


float3x3 GetRotationMatrix(float3 angles)
{
    
    float pitch = fmod(angles.z, 2 * PI);
    float yaw = fmod(angles.y, 2 * PI);
    float roll = fmod(angles.x, 2 * PI);
    
    float sa = sin(pitch);
    float sb = sin(yaw);
    float sc = sin(roll);
    
    float ca = cos(pitch);
    float cb = cos(yaw);
    float cc = cos(roll);
    
    return float3x3(
                    cb*ca + sb*sc*sa, -sa*cb + sb * sc * ca, sb*cc,
                    cc * sa,cc * ca,-sc,
                    -sb * ca + cb * sc * sa, -sb*-sa+ cb * sc * ca,cb * cc
    );

}

struct MaterialProperties
{
    float3 diffuseColor;
    float3 specularColor;
    float3 emissiveColor;
    float3 transmissiveColor;
    float diffuse;
    float specular;
    float emissive;
    float opacity;
    float refraction;
    
};

struct ShaderObject
{
    int id;
    int type;
    float3 position;
    float3 scale;
    float3 rotation;
    MaterialProperties material;
};
struct Ray
{
    float n;
    float3 origin;
    float3 direction;
};
struct RayHit
{
    float3 position;
    float3 normal;
    float distance;
    bool inside;
    MaterialProperties mat;
};
struct LightDirectional
{
    float3 position;
    float3 direction;
    float3 color;
    float intensity;
};

struct LightPoint
{
    float3 position;
    float3 color;
    float intensity;
};


StructuredBuffer<ShaderObject> _Objects;
StructuredBuffer<double> _PixelOffset;

MaterialProperties CreateMaterial()
{
    MaterialProperties mat;
    mat.diffuseColor = f3one;
    mat.diffuse = 1;
    mat.emissive = 0;
    mat.emissiveColor = f3one;
    mat.specular = 1;
    mat.specularColor = f3one;
    mat.refraction = 1;
    mat.transmissiveColor = f3zero;
    mat.opacity = 0;
    return mat;
}

RayHit CreateRayHit()
{
    RayHit ret;
    ret.distance = 1.#INF; //any hit should be less than this.
    ret.position = f3zero;
    ret.normal = f3zero;
    ret.inside = false;
    ret.mat = CreateMaterial();
    return ret;

}

float float3ToFloat(float3 a)
{
    normalize(a);
    return a.x + a.y * 10 + a.z * 100;
}

float randFloat(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return float(s) / 4294967295.0; // 2^32-1
}
float randFloat(float s)
{
    return randFloat(asuint(s));
}
float3 randFloat3(float s)
{
    return float3(2.0 * randFloat(s + _RandomSeed) - 1, 2.0 * randFloat(s + 1 + _RandomSeed) - 1, 2.0 * randFloat(s + 2 + _RandomSeed) - 1);
}
float3 randFloat3(float3 s)
{
    return randFloat3(float3ToFloat(s) + _RandomSeed);
}
float3 randDirection(float3 s)
{
    float3 f3 = float3(1, 1, 1);

    while (length(f3) > 1.0)
    {
        f3 = randFloat3(s);
    }
    return f3;
}
bool randBool(float s, float p)
{
    return randFloat(s) <= p;
}
bool randBool(float3 s, float p)
{
    return randBool(float3ToFloat(s), p);
}

void IntersectionTestPlane(ShaderObject object, Ray ray, inout RayHit bestHit)
{
    float3x3 rotationMatrix = GetRotationMatrix(object.rotation);
    float3 normal = mul(rotationMatrix, float3(0, 1, 0)); //TODO: precompute this - it should take far fewer calculations
    
    float normalDotDirection = dot(normal, ray.direction);
    
    float t = dot((object.position - ray.origin), normal) / normalDotDirection;
    float3 hitPoint = ray.origin + ray.direction * t;
    if (t > 0 && t < bestHit.distance)
    {
        float3 localposition = mul(transpose(rotationMatrix), float3(hitPoint-object.position));
        if (abs(localposition.z) <= object.scale.z / 2 && abs(localposition.x) <= object.scale.x / 2)
        {
            if (dot(normal, ray.direction) > 0)
            {
                bestHit.normal = -normalize(normal);
            }
            else
            {
                bestHit.normal = normalize(normal);
            }
            bestHit.position = hitPoint;
            bestHit.distance = t;
            bestHit.mat = object.material;
        }
    }
}

void IntersectionTestSphere(ShaderObject object, Ray ray, inout RayHit bestHit)
{
    float3 dPosition = ray.origin - object.position;
    float uDotDPosition = -dot(ray.direction, dPosition);
    float del = pow(uDotDPosition, 2) - (dot(dPosition, dPosition) - pow(object.scale.x, 2));

    if (del < 0)
        return; //No Intersection
    
    float sqrtDel = sqrt(del);
    float t = uDotDPosition - sqrtDel > 0 ? uDotDPosition - sqrtDel : uDotDPosition + sqrtDel;
    if (t > 0 && t < bestHit.distance)
    {
        float3 position = ray.origin + t * ray.direction;
        
        
        float3 normal = normalize(position - object.position);
        if (dot(normal, ray.direction) > 0)
        {
            bestHit.normal = -normal;
        }
        else
        {
            bestHit.normal = normal;
        }
        
        bestHit.position = position;
        bestHit.distance = t;
        bestHit.mat = object.material;
    }
}


RayHit Trace(Ray ray)
{
    //Empty Ray Collision
    ray.direction = normalize(ray.direction);
    
    RayHit bestHit = CreateRayHit();
    
    uint numObjects, stride;
    _Objects.GetDimensions(numObjects, stride);
    for (uint i = 0; i < numObjects; i++)
    {
        switch (_Objects[i].type)
        {
            case 0:
                IntersectionTestSphere(_Objects[i], ray, bestHit);
                break;
            case 1:
                IntersectionTestPlane(_Objects[i], ray, bestHit);
                break;
            case 2:
                //IntersectionTestCube(_Objects[i], ray, bestHit);
                break;
        }
    }
    return bestHit;
}

float3 RefractRay(float n1, float n2, float3 direction, float3 normal)
{
    direction = normalize(direction);
    normal = normalize(-normal);
    float dirDotNormal = dot(direction, normal);
    return (direction - normal * dirDotNormal + normal * sqrt(n2 * n2 - n1 * n1 + dirDotNormal * dirDotNormal));
}
float ReflectionCoefficient(float n1, float n2, float3 direction, float3 normal)
{
    float theta1 = acos(dot(normalize(normal), normalize(-direction)));
    
    float sinTheta2 = (n1 / n2 * sin(theta1));
    if(sinTheta2 > 1)
        return 1; //Total Internal Reflection
    
    float theta2 = asin(sinTheta2);
    
    float rsSqrt = (n1 * cos(theta1) - n2 * cos(theta2)) / (n1 * cos(theta1) + n2 * cos(theta2));
    float rpSqrt = (n1 * cos(theta2) - n2 * cos(theta1)) / (n1 * cos(theta2) + n2 * cos(theta1));
    return (rsSqrt * rsSqrt + rpSqrt * rpSqrt) / 2.0;
}

float3 RayTrace(Ray ray)
{
    RayHit hit = CreateRayHit();
    float3 result = f3zero;
    float3 colorMultiplier = f3one;
    
    for (int i = 0; i < _Rays; i++)
    {
        hit = Trace(ray); //Emit Ray & Get Hit Info
        result += (hit.mat.emissiveColor * hit.mat.emissive) * colorMultiplier;
        
        //If ray hits something
        if (hit.distance < 1.#INF && length(colorMultiplier) > 0.1f)
        {
            //Calculate probability of reflection
            float reflectance = ReflectionCoefficient(ray.n, hit.mat.refraction, ray.direction, hit.normal);
            ray.origin = hit.position + hit.normal * epsilon;
            
            //Sample reflectance probability
            if (randBool(ray.direction, reflectance))
            {
                //Reflection
                colorMultiplier *= hit.mat.specularColor * hit.mat.specular * reflectance;
                ray.direction = reflect(ray.direction, hit.normal);
            }
            else if (randBool(ray.direction, hit.mat.opacity))
            {
                //Scatter
                float3 lambertianScatteringDirection = randDirection(ray.direction);
                if (dot(lambertianScatteringDirection, hit.normal) > 0)
                {
                    -lambertianScatteringDirection;
                }
                ray.direction = normalize(lambertianScatteringDirection / length(lambertianScatteringDirection));
                //return ray.direction;
                colorMultiplier *= hit.mat.diffuseColor * hit.mat.diffuse * (1 - reflectance);
                    
            }
        }
        else break;
    }
    return result;
}


Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.n = 1;
    ray.origin = origin;
    ray.direction = normalize(direction);
    return ray;
}
Ray CreateCameraRay(double2 uv)
{
    //Alright realistically, we don't need to transform the camera position/rotation and could do the inverse for easier culling?
    //something to try at some point.
    
    // Transform the camera origin to world space
    double3 origin = mul(_CameraToWorld, float4(f3zero, 1.0f)).xyz;
    
    //direction of cam ray
    double3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    
    //MMMMMMMmmmmmmMMMmmaaaatttrrrriiixxxxxxx
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = (direction / length(direction));
    
    return CreateRay(origin, direction);
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    
    double2 po = double2(_PixelOffset[0], _PixelOffset[1]);
    double2 uv = double2((id.xy + po) / double2(width, height) * 2.0 - 1.0);
    
    Ray ray = CreateCameraRay(uv);
    
    float3 result = RayTrace(ray);
    
    Result[id.xy] = float4(result, 1.0);
}
